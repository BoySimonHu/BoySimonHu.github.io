[{"title":"iOS 关于架构的一些想法","date":"2020-08-15T05:27:55.000Z","path":"2020/08/15/iOS 关于架构的一些想法/","text":"iOS 关于架构的一些想法什么是架构？&emsp;&emsp;架构这个概念是源起于建筑学中。在软件设计中，架构又分了许多种类，有应用架构、企业架构 基础设施架构。其中我们现在这个阶段应该学习的就是应用架构，应用架构主要是一个以 解决某个特定的问题 为核心目标的内部结合结构。一般是为了某个业务需求为目标来进行设计的。 为什么要有架构？&emsp;&emsp;很简单，一个分工不明确的团队，是没有什么发展前景的。单个人的能力和时间总是有限的，只有不同分工的人才可以更容易的组成一个完整的、稳固的、高效的团体。连踢足球都有不同的分位，更别说咱们软件开发了。&emsp;&emsp;回归到咱们日常的开发上来说，一个简单的可交互页面，你可以把所有的逻辑都放在VC下面，这对于需求的完成来说没什么问题。可是随着业务的膨胀，VC的代码也是会随之膨胀的。一个1000行代码，不提开发人员有多难去看，就单从架构的角度上来讲，也总是能找出来一堆问题的。 How？&emsp;&emsp;一个不想成为架构师的程序员不是个好的穷人 1. 确认和熟悉需求&emsp;&emsp;我们平时开发的时候经常会在第一手拿到需求的时候，粗略的看几眼然后就开始紧锣密鼓的码代码了，这种时候我们的总体目标一般只有一个：需求按时写完，功能可以实现。对于结果向的公司来说，这并没有什么不对，但对于我们自身来说会直接导致一个直接问题，我们的技术并没有因为代码量的增加而提升，这种现象其实也就是大家常说的写业务不能提升技术。&emsp;&emsp;想改变这种情况的话，我们在拿到需求的时候，应该学会慢下来。仔细的去理解需求，尝试懂得需求方的想法，并不同的和需求方反复沟通，保证自己可以精准的理解需求，为接下里对做需求拆分打下基础。俗话说得好，磨刀不费砍柴工。 2. 需求拆分、系统分解&emsp;&emsp;需求拆分可能大部分是产品去做，我们技术应该更加关注的是系统的分解。在拆分策略中，大致可以分为纵向拆分和横向拆分两种。 纵向拆分。是从业务维度进行拆分。标准是按照业务的关联程度来决定，关联比较密切的业务适合拆分为一个子系统，而功能相对比较独立的业务适合单独拆成一个子组件。例如一个商品系统中，纵向拆分可以分为订单系统、用户系统、产品系统等。 横向拆分。从公共且独立功能维度拆分。标准是按照是否有公共的被多个其他模块调用，且依赖的资源独立不与其他业务耦合。还是一个商品系统，从横向可以将订单的增删改查单独拆出来作为公共组件，每个业务模块的调用方可以单独使用这个公共组件。&emsp;&emsp;纵向拆分主要从业务角度进行，根据业务分割为不同的子系统；而横向拆分侧重于原业务深入拆分，然后服务重组。 3. 技术选型&emsp;&emsp;对于我们客户端开发来说，这一步基本上是在选择实现需求的具体方案。例如使用MVC还是用MVVM，使用OC开发还是Swift开发等等一系列的方案。&emsp;&emsp;当我们选取具体的技术方案的时候，还是需要从业务的角度出发去进行思考。除了需要符合六大原则之外，还要考虑到是否和需求真正的契合。比如一个单纯的页面展示，本来一个简单点MVC就可以满足，非要用VIPER实现，这种是没有必要的。&emsp;&emsp;以我自身为例，在技术选型的时候，一般我会先确定一个目标。例如一个产品形态可复用情况下，我可能会以实现技术模块的可拓展和业务解耦为主要目标；一个有着固定流程的业务，我可能就会以实现流程细分、数据流共享等方面减少每个流程的副作用为主要目标。这一步其实是我们最能提升编码能力的地方。每次的需求大家都可以尝试着去使用不同的方案去实现自己的业务，从而摆脱写业务不能提升技术的窘境。 4. 制定统一的规范&emsp;&emsp;其实到了第三步，对于我们来说基本上就完成了对一个需求的架构，但是我们都是想成为架构师的程序猿们，所以身为架构师应该做的规范统一，我们也应该去尽量尝试。&emsp;&emsp;架构师不止要在技术上可以提供方案，也应该懂得组织协调和人员分工，需要制定统一的开发规范，让开发人员可以从不同的视角监测自己所负责的模块。 自己的一些想法关于写业务的程序员这个话题&emsp;&emsp;和很多朋友沟通后发现，当一个业务需求和一个技术需求摆在你面前的时候，包括以前的我，大家都不愿意去触碰那个业务需求，理由就是业务需求不能提升自我的技术能力。但是仔细的去分析开发的现状，大部分的人都是在一个业务型的公司工作的，业务是企业存活的唯一标准，好的架构设计出来的意义就是更好的去做业务需求的开发。从12306的技术提升到阿里业务中台的概念推广，其实都是在服务于业务。所以对待业务开发，我个人现在是以开放的态度去接受的，再好的技术终归要落地到业务上。（当然，纯技术向的朋友当我没说） 关于「斜杠」程序员的看法&emsp;&emsp;此处的斜杠并不是说的兼职一类的东西，而是说很多程序员基本上都会接触多种开发语言。但是接触的多了就会有学而不精的感觉。从我个人的角度上来说，我会选取一个主要方向，开辟分支的主要目的也是更好的发展主要方向。在主要方向上可以闲庭信步的时候，再去攻克另一个高峰。&emsp;&emsp;例如我现在的主要发展的是iOS开发，那么我会选择学习js、python、ruby这些语言作为工具语言来辅助我做iOS开发。我在学习iOS的Rx和RAC的时候，我会去参考js上的一些语法帮助我理解函数式的一些概念，而且多数的语言之间都是有共通性的。从架构和设计模式的角度上来说，这些思想是没有技术栈的区分的，语言不同但思想共通。 关于iOS的成长路径个人对于iOS成长的路径上的「初中高架构师」的理解： 熟悉语言，找到自己的开发节奏 –&gt; 初级 意识到设计模式的重要性，更注重自我的编码能力 –&gt; 中级 对于自己开发的App可以进行整体的架构把控和性能把控 –&gt; 高级 有自己成熟的性能优化方案，根据不同的业务场景可以做出正确的架构设计，拥有团队管理能力，可以对整个团队的技术发展进行把控 –&gt; 架构师 所需的基础知识面向对象的六大原则 单一职责原则 开闭原则 依赖倒转原则 合成复用原则 迪米特法则 接口隔离原则 设计模式 学习网站 最后的最后，留个两个问题 如何设计一个支付流程 如何设计一个设置中心（显示不同cell样式、点击cell响应不同的事件、cell加载不同的数据）","tags":[{"name":"周六叨叨叨-朋友之间的小分享","slug":"周六叨叨叨-朋友之间的小分享","permalink":"http://boysimonhu.com/tags/%E5%91%A8%E5%85%AD%E5%8F%A8%E5%8F%A8%E5%8F%A8-%E6%9C%8B%E5%8F%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B0%8F%E5%88%86%E4%BA%AB/"}]},{"title":"Podfile 语法以及基本使用","date":"2020-01-19T08:58:09.000Z","path":"2020/01/19/Podfile的使用/","text":"pod install 的基本流程 查看 ~/.cocoapods/repo/master/Specs 是否存在 存在，从这个本地三方库信息库中获取 Podfile 中对应三方库的 git 地址 不存在，输出 Setting up CocoaPods Master repo，并- 拉取三方库信息库到 ~/.cocoapods/repo/中 使用 git 命令从 GitHub 上拉取 Podfile 中对应的三方库源码 Podfile是什么？Podfile是一种规范，描述一个或多个xcode项目目标的依赖项 最简单的写法： 12target &#39;MyApp&#39;pod &#39;AFNetworking&#39;, &#39;~&gt; 1.0&#39; 一种复杂的写法 1234567891011121314151617platform :ios, &#39;9.0&#39;inhibit_all_warnings!target &#39;MyApp&#39; do pod &#39;ObjectiveSugar&#39;, &#39;~&gt; 0.5&#39; target &#39;MyAppTests&#39; do inherit! :search_paths pod &#39;OCMock&#39;, &#39;~&gt; 2.0.1&#39; endendpost_install do |installer| installer.pods_project.targets.each do |target| puts &quot;#&#123;target.name&#125;&quot; endend 主配置Podfile的全局可用配置 install! CocoaPods的安装方法，用于设置安装方法和安装时的选项，在Podfile的安装时期调用 一共有两个参数，第一个参数是说明安装方法，第二个参数是用来说明安装选项。例如： 123install! &#39;cocoapods&#39;, &#x2F;&#x2F; 用来说明使用cocoapods方法进行安装 :deterministic_uuids &#x3D;&gt; false, &#x2F;&#x2F; 忽略uuid重复检查 :integrate_targets &#x3D;&gt; false &#x2F;&#x2F; 是否将已安装的pod集成到工程中 涉及到的安装选项： 12345678910111213141516171819202122232425262728293031323334353637383940414243:clean移除不被podspec用到和工程不支持平台的文件，默认true:deduplicate_targets是否对目标库进行去重处理，当不同的target对同一个库有不同的需求时，会在库之后添加相应的后缀，默认true，例如：target &#39;MyTargetA&#39; do pod &#39;MyPod&#x2F;SubA&#39;endtarget &#39;MyTargetB&#39; do pod &#39;MyPod&#39;end结果为 MyPod 和 MyPod-SubA:deterministic_uuids ??uuid重复检查 默认true:integrate_targets是否将下载下来的三方库集成到工程中，false则只会讲三方下载到Pods文件夹中，不会集成，默认true:lock_pod_sources是否锁定pod下载下来的文件（文件右上角的锁），加锁会明显的影响install速度，默认为true:warn_for_multiple_pod_sources当多个pod源存在包含相同库名和版本时，是否警告，默认为true:share_schemes_for_development_pods是否允许三方库共享schemes，默认为false:disable_input_output_paths --- 需要check是否禁用CocoaPods脚本阶段的输入和输出路径（复制框架和复制资源），默认为false:preserve_pod_file_structure是否保留所有的pod结构，包括额外的pod资源，true时会保存库原有的文件结构, 默认为false:generate_multiple_pod_projects 是否生成多个pod的project，true时会在Pods.xcodeproj下生成每个pod的子project，默认为false:incremental_installation --- 需要check是否仅启用重新生成自上次安装以来已更改的目标及其关联项目，默认为false:skip_pods_project_generation --- 需要check(和integrate_targets区别？)是否跳过生成Pods.xcodeproj，仅执行依赖项解析和下载。默认为false 依赖pod声明一个工程中所用到的依赖 一个依赖的声明，由库名称和库版本组成，其中库版本为可选项。 不加库版本号： 1pod &#39;SSZipArchive&#39; # 每次install都将会拉取库的最新版本 指定库的版本号 1pod &#39;SSZipArchive&#39;, &#39;0.9&#39; # 每次install，都将固定拉取库的某个版本 除了以上两种方式，还可使用运算符进行版本限制 = 1.0 固定版本号为1.0 &gt; 1.0 大于1.0 &gt;= 1.0 大于1.0，包括1.0 &lt; 1.0 小于1.0 &lt;= 1.0 小于1.0，包括1.0 ~&gt; 0.1.2 0.2以下、不包括0.2，等同于 &gt;= 0.1.2 &amp;&amp; &lt; 2.0 ~&gt; 0.1.3-beta.0 测试和发布版本的0.1.3，发布版本在0.2以下，且不包含0.2。用破折号（-）分隔的组件将不考虑版本要求。 Build configurations默认依赖是将会安装在工程的所有target上，但是实际开发中，由于调试或者是其他的要求，需要将依赖只安装在部分target上。 12pod &#39;PonyDebugger&#39;, :configurations &#x3D;&gt; [&#39;Debug&#39;, &#39;Beta&#39;]将PonyDebugger只安装在Debug和Beta target下 或 12pod &#39;PonyDebugger&#39;, :configuration &#x3D;&gt; &#39;Debug&#39;只将PonyDebugger安装在Debug下。 Modular Headers某个库需要使用Modular Headers时： 1pod &#39;SSZipArchive&#39;, :modular_headers &#x3D;&gt; true 如果已经使用了use_modular_headers!属性，但是某个库又不需要使用Modular Headers： 1pod &#39;SSZipArchive&#39;, :modular_headers &#x3D;&gt; false Source默认情况下，pod install都将会从https://github.com/CocoaPods/Specs.git源下去拉取库。也可指定单个库的源 1pod &#39;PonyDebugger&#39;, :source &#x3D;&gt; &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39; Note: 当我们使用某几个库，或者是使用自己制作的私有库时，可以在podfile的开头先指定源 1source &#39;https:&#x2F;&#x2F;github.com&#x2F;CocoaPods&#x2F;Specs.git&#39; Subspecs一个库中可能会包含多个子库，默认的安装方式，会将所有的子库全部下载下来，若只需要某个子库，则可以使用以下方法： 12345# 下载QueryKit中的Attribute子库pod &#39;QueryKit&#x2F;Attribute&#39;# 下载QueryKit中的Attribute和QuerySet子库pod &#39;QueryKit&#39;, :subspecs &#x3D;&gt; [&#39;Attribute&#39;, &#39;QuerySet&#39;] Test Specs:testspecs选项可用将pod库的测试代码下载下来，默认情况下不会拉取此部分的代码，声明方式如下： 1pod &#39;AFNetworking&#39;, :testspecs &#x3D;&gt; [&#39;UnitTests&#39;, &#39;SomeOtherTests&#39;] 若想让pod库支持该选项，需要在Podspec中添加test_spec 使用本地路径在实际开发中，可能会在工程中修改某些库的代码，这种情况下，使用本地路径的方式可以更方便的完成开发: 1pod &#39;AFNetworking&#39;, :path &#x3D;&gt; &#39;~&#x2F;Documents&#x2F;AFNetworking&#39; Note: 由于这种方式实际上是链接本地目录，所以使用该方式修改的代码是会被保存下来的。 从远程仓库目录中的podspec获取我们可以直接拉取远程仓库的某个分支或某个commit的代码 1234567891011# 拉取AFNetworking的master分支代码pod &#39;AFNetworking&#39;, :git &#x3D;&gt; &#39;https:&#x2F;&#x2F;github.com&#x2F;gowalla&#x2F;AFNetworking.git&#39;# 拉取AFNetworking的dev分支代码pod &#39;AFNetworking&#39;, :git &#x3D;&gt; &#39;https:&#x2F;&#x2F;github.com&#x2F;gowalla&#x2F;AFNetworking.git&#39;, :branch &#x3D;&gt; &#39;dev&#39;# 拉取AFNetworking的0.7.0 tag的代码pod &#39;AFNetworking&#39;, :git &#x3D;&gt; &#39;https:&#x2F;&#x2F;github.com&#x2F;gowalla&#x2F;AFNetworking.git&#39;, :tag &#x3D;&gt; &#39;0.7.0&#39;# 拉取AFNetworking中commit号为082f8319af的代码pod &#39;AFNetworking&#39;, :git &#x3D;&gt; &#39;https:&#x2F;&#x2F;github.com&#x2F;gowalla&#x2F;AFNetworking.git&#39;, :commit &#x3D;&gt; &#39;082f8319af&#39; Note： 本地路径中的库，若也是使用pod管理，则同样可以指定分支 1pod &#39;AFNetworking&#39;, :path &#x3D;&gt; &#39;~&#x2F;Documents&#x2F;AFNetworking&#39;, :branch &#x3D;&gt; &#39;dev&#39; 从远程source之外的地方获取podspec配置如果想拉取一个不在source上的podspec配置，则可以使用:podspec方式进行拉取。注意podspec需要是一个http的资源 1pod &#39;JSONKit&#39;, :podspec &#x3D;&gt; &#39;https:&#x2F;&#x2F;example.com&#x2F;JSONKit.podspec&#39; script_phase可以通过Podfile先target中添加脚本 1234567target &#39;ZipApp&#39; do script_phase :name &#x3D;&gt; &#39;HelloWorldScript&#39;, :script &#x3D;&gt; &#39;echo &quot;Hello World&quot;&#39; script_phase :name &#x3D;&gt; &#39;HelloWorldScript&#39;, :script &#x3D;&gt; &#39;puts &quot;Hello World&quot;&#39;, :shell_path &#x3D;&gt; &#39;&#x2F;usr&#x2F;bin&#x2F;ruby&#39; pod &#39;SSZipArchive&#39;end 抽象target可以定义abstract_target来方便其他的target进行继承 123456789101112131415161718192021222324252627282930313233# Defining an abstract targetabstract_target &#39;Networking&#39; do pod &#39;AlamoFire&#39; target &#39;Networking App 1&#39; target &#39;Networking App 2&#39;end# Note: There are no targets called &quot;Shows&quot; in any of this workspace&#39;s Xcode projectsabstract_target &#39;Shows&#39; do pod &#39;ShowsKit&#39; # The target ShowsiOS has its own copy of ShowsKit (inherited) + ShowWebAuth (added here) target &#39;ShowsiOS&#39; do pod &#39;ShowWebAuth&#39; end # The target ShowsTV has its own copy of ShowsKit (inherited) + ShowTVAuth (added here) target &#39;ShowsTV&#39; do pod &#39;ShowTVAuth&#39; end # Our tests target has its own copy of # our testing frameworks, and has access # to ShowsKit as well because it is # a child of the abstract target &#39;Shows&#39; target &#39;ShowsTests&#39; do inherit! :search_paths pod &#39;Specta&#39; pod &#39;Expecta&#39; endend inherit!有三种类型： :complete 继承父级所有行为； :none 什么行为都不继承； :search_paths 继承父级的 search paths 12345target &#39;App&#39; do target &#39;AppTests&#39; do inherit! :search_paths endend target配置用来控制CocoaPods最后生成的Project platform声明库支持的平台，默认为4.3 for iOS, 10.6 for OS X, 9.0 for tvOS and 2.0 for watchOS 参数： 平台名称 指定版本123platform :ios, &#39;4.0&#39;# 或platform :ios project声明xcode工程应该与哪个target相链接，指定Pod管理的项目路径 1234567891011# This Target can be found in a Xcode project called &#96;FastGPS&#96;target &#39;MyGPSApp&#39; do project &#39;FastGPS&#39; ...end# Same Podfile, multiple Xcodeprojectstarget &#39;MyNotesApp&#39; do project &#39;FastNotes&#39; ...end inhibit_all_warnings!消除编译警告，默认全局。 如果指向消除某个库的编译警告，可使用如下语法: 1pod &#39;SSZipArchive&#39;, :inhibit_warnings &#x3D;&gt; true 或 全局消除下，依然让某个库有警告： 1pod &#39;SSZipArchive&#39;, :inhibit_warnings &#x3D;&gt; false use_modular_headers!全局使用modular_headers，局部同上 use_frameworks!Pod使用静态库 supports_swift_versions支持的swift版本 1234target &#39;MyApp&#39; do supports_swift_versions &#39;&gt;&#x3D; 3.0&#39;, &#39;&lt; 4.0&#39; pod &#39;AFNetworking&#39;, &#39;~&gt; 1.0&#39;end 123456789supports_swift_versions &#39;&gt;&#x3D; 3.0&#39;, &#39;&lt; 4.0&#39;target &#39;MyApp&#39; do pod &#39;AFNetworking&#39;, &#39;~&gt; 1.0&#39;endtarget &#39;ZipApp&#39; do pod &#39;SSZipArchive&#39;end WorkspaceWorkspace配置以及全局设置 workspace生成的workspace路径，可用来修改最后workspace的生成名称，默认与工程名称相同 1workspace &#39;MyWorkspace&#39; generate_bridge_support!生成BridgeSupport文件 set_arc_compatibility_flag!指定-fobjc-arc标志应添加到OTHER_LD_FLAGS Hooks在install过程中调用，Hook是全局的，不会针对某个target进行操作 plugin使用插件进行Hook 1234# 使用插件cocoapods-keys，传递参数Eidolonplugin &#39;cocoapods-keys&#39;, :keyring &#x3D;&gt; &#39;Eidolon&#39;# 使用插件slatherplugin &#39;slather&#39; pre_install在pod下载后安装之前做一些操作。 123pre_install do |installer| # Do something fancy!end post_install在生成xcode项目之前，做最后的更改，installer是该方法唯一的参数 1234567post_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings[&#39;GCC_ENABLE_OBJC_GC&#39;] &#x3D; &#39;supported&#39; end endend","tags":[{"name":"CocoaPods相关","slug":"CocoaPods相关","permalink":"http://boysimonhu.com/tags/CocoaPods%E7%9B%B8%E5%85%B3/"}]},{"title":"App之间的数据共享——App Group的配置","date":"2017-12-10T08:51:04.000Z","path":"2017/12/10/App之间的数据共享——App-Group的配置/","text":"在实际的开发中，我们也许会有这种需求： 公司的旗下有两个App，当客户已经登录一个App A的情况下，再登录另一个App B时，B不再需要繁琐的登录过程就可以直接使用A已经登录的信息。但是iOS系统下有这么一个安全机制：每个应用都有自己对应的沙盒，每个沙盒之间都是相互独立的，互不能访问（没有越狱的情况下）。这种情况，我们应该怎么处理呢？ 一、认识App GroupsAppGroup allows data sharing between two different apps or even app and widgets by creating one common shared path (like document directory). Data saved over there can be accessed by any app which is associated with that particular AppGroup. It is an offline data sharing between apps.这是一段关于App groups的一段说明，告诉我们了App Groups可以使两个不同的APP进行数据共享，看起来这个是解决我们刚才那个问题的好方法。那就让我们开启我们的数据共享之旅吧！ 二、创建APP 创建两个app，分别命名为MainApp, SubApp（为了写文章，我重新新建了两个app，只怪自己写Demo命名太乱来 ）。 在Apple Developer中配置两个app的App ID： 当我们创建app id的时候不要忘记把App Services选项中的App Groups给勾上哦，这样才能够保证我们接下来可以使用App Groups。当我们配置完成App ID之后，会发现App Groups是Configurable状态，这是因为咱们还没有配置相应的app groups，别着急，咱们等会再来管它。 在Apple Developer中配置两个app的Profile（这里我只配置了dev的profile）：一次从简，我这不再赘述profile的配置了，只贴上两张图表示一下。。。 三、创建App Groups接下来就到了我们的重头戏：App Groups 还是要打开Apple Developer，在id那一组中又一个App Groups选项，打开就是如下的画面（多么庆幸这一个账号从没设置过任何的组）： 然后我们Continue:纳尼！！就这两个选项？？？没错，就这两个选项，第一个是我们这个app group的描述，第二个是我们app group的id。这个id默认是要group.打头，并且是不能去掉的 还记得咱们刚才App ID的一个Configurable状态吗？咱们现在就去收拾它去~~ 点击Edit—勾选上刚创建好的App Group—-配置完成，在返回来看一下咱们的App ID，完美~Enabled状态了。 四、在程序中配置App Group 分别打开两个程序，切换到Capabilities选项卡，找到App Groups选项，刷新一下，将App developer中的App Groups同步下来，然后勾选上咱们刚才创建的开发组。 当我们配置完以后，会在文件目录下多出来一个.entitlements的文件。 五、用代码，创建共享文件配置工作做完了，接下来，就是我们的代码表现的时间了。在这里，我只创建了一个.txt来存储数据，其他类型的持久化存储同理废话不多说，贴代码： 首先是Main App写入数据 123456789&#x2F;&#x2F;Main App 通过TextField来向共享文件appGroup.txt中写入数据- (void)textFieldDidEndEditing:(UITextField *)textField &#123; &#x2F;&#x2F;获取App Group的共享目录 NSURL *groupURL &#x3D; [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@&quot;group.com.simon.app.test&quot;]; NSURL *fileURL &#x3D; [groupURL URLByAppendingPathComponent:@&quot;appGroup.txt&quot;]; &#x2F;&#x2F;写入文件 [textField.text writeToURL:fileURL atomically:YES encoding:NSUTF8StringEncoding error:nil];&#125; 接下来是Sub App读数据 123456789&#x2F;&#x2F;Sub App 通过获取appGroup.txt中的数据，展现在label上&#x2F;&#x2F;获取App Group的共享目录 NSURL *groupURL &#x3D; [[NSFileManager defaultManager] containerURLForSecurityApplicationGroupIdentifier:@&quot;group.com.simon.app.test&quot;]; NSURL *fileURL &#x3D; [groupURL URLByAppendingPathComponent:@&quot;appGroup.txt&quot;]; &#x2F;&#x2F;读取文件 NSString *str &#x3D; [NSString stringWithContentsOfURL:fileURL encoding:NSUTF8StringEncoding error:nil]; self.shareLabel.text &#x3D; str; containerURLForSecurityApplicationGroupIdentifier当当当，没错，就是这个方法，用来在share path中创建share document。ps: 抛给大家个问题，感兴趣的同学可以试着找一下分享目录在哪，对于喜欢搞机的朋友来说这个问题so easy 现在运行一下，来看一下效果：Main App输入数据Sub App输出数据 可能细心的小伙伴看见了jump to sub和jump to main，这两个button是利用了URL Types进行的简单的app跳转，有兴趣的童鞋可以自己尝试一下。 六、结语到现在为止，最简单的两个app之间的数据共享已经说完了，但是这离项目的实际应用还是有段距离的，建议大家可以根据业务自己封装一个数据共享类来方便自己正在项目中的使用~ 简书地址","tags":[{"name":"iOS日常开发","slug":"iOS日常开发","permalink":"http://boysimonhu.com/tags/iOS%E6%97%A5%E5%B8%B8%E5%BC%80%E5%8F%91/"}]},{"title":"CocoaPods的安装和使用（心得）","date":"2017-06-07T14:18:37.000Z","path":"2017/06/07/CocoaPods的安装和使用（心得）/","text":"上周五由于项目需要，我把一个有Pods项目改了名，可恨的是电脑上的CocoaPods挂掉了，公司网差。只好周末的时候在家奋斗了一下，功夫不负有心人，最后是被我搞好了，由于出现了好多问题，所以在这把自己的安装心得说一下，仅供大家参考！ CocoaPods简介： CocoaPods是什么呢？它负责管理iOS项目中第三方开源库的工具，它的项目源码都在Github上管理的，那么问题又来了，Github是什么呢？(### 被扔西红柿)，咳咳~这个我就不在这废话了。我们开发iOS项目时不可避免地要使用第三方开源库（现在第三方开源库的使用率比前些年更多了，建议大家在允许的条件下 最好是能够自己造些轮子），CocoaPods的出现使得我们可以节 省配置和更新第三方开源库的时间和精力。###安装前奏首先要提一下CocoaPods的安装顺序: 1Xcode -&gt; homebrew -&gt; RVM -&gt; Ruby -&gt; CocoaPods Xcode不用说。。大家也没有不知道的。 homebrew是什么？接触过Linux的同学应该挺熟悉yum的，没错，homebrew就是OS的yum，一款软件管理工具。 RVM 它的全程是Ruby Version Manager，大家看名字也应该可以了解到，这是一款命令行管理工具，能够轻松的管理Ruby的版本。 Ruby 这是一款专门为面向设计编程制作的脚本语言，简单易用，功能强大。 关于这几个工具的安装我就不在这篇文章中赘述了，有需要的我再专门写一篇关于他们的安装。###安装正式开始 首先使用Ruby的gem命令来进行安装12$ sudo gem install cocoapods$ pod setup 敲完这些以后，你会突然发现，卡住了。恭喜你，体验了一把被“墙”的感觉。这是因为Ruby的源（安装源）https://rubygems.org/是亚马逊的云服务（这个说真的我是之前在唐巧大神的博客中了解到的），这个时候大部分的教程都会叫你换成淘宝的源淘宝的源:https://ruby.taobao.org/，不过…….. 没错，停止维护了，更具淘宝源上的提示，现在源应该使用http://gems.ruby-china.org/这个。好的问题，解决了，那么让我们换一下ruby的源吧 123gem sources --remove https:&#x2F;&#x2F;rubygems.org&#x2F; &#x2F;&#x2F;删除gem sources -a http:&#x2F;&#x2F;gems.ruby-china.org&#x2F;gem sources -l 你会发现新的ruby源已经安装完毕，完美~ 继续pod setup命令，这个时候终端会出现Setting up CocoaPods master repo，这个步骤 Cocoapods 会将它的信息下载到Mac的~/.cocoapods目录下，然后漫长的等待来了（表示楼主在这个阶段过一会就预览一下/.cocoapods/repos/master的大小，当然也可以cd到目录下用du -sh *命令查看进度，速度挺快，一分钟能走1MB了呢&gt;_&lt;||| ）。####使用 CocoaPods 的镜像索引是不是等不下去了？好吧，告诉一个可以提高下载速度的方法，那就是使用CocoaPods的镜像索引。所有的项目的 Podspec 文件都托管在https://github.com/CocoaPods/Specs，第一次执行pod setup时，CocoaPods 会将这些podspec索引文件更新到本地的 ~/.cocoapods/目录下.一个叫 akinliu 的朋友在 gitcafe 和 oschina 上建立了 CocoaPods 索引库的镜像，因为 gitcafe 和 oschina的服务器都是在国内，所以在执行索引更新操作时，会快了好多。如下操作可以将 CocoaPods 设置成使用 gitcafe 镜像：1pod repo remove masterpod repo add master https:&#x2F;&#x2F;gitcafe.com&#x2F;akuandev&#x2F;Specs.gitpod repo update 使用 oschina 镜像：1pod repo remove masterpod repo add master http:&#x2F;&#x2F;git.oschina.net&#x2F;akuandev&#x2F;Specs.git ###CocoaPods使用安装完成后，我们就可以安心的来使用CocoaPods了 使用CocoaPods有一个前提，是我们的项目目录下必须要有一个Profile的文件，那这个文件要怎么创建呢：12cd &#39;&#39;项目根目录&#39;&#39;pod init OK，搞定这个时候使用vim Profile命令编辑Profile里的内容，将依赖库名字依次列在Profile中，最终格式如下： 其中target &#39;Demo&#39; do和#Pods for Demo中的Demo是我的工程名。 到现在为止，你的Profile就已经配置好了，然后执行：1pod install 等待完成后，你的第三方库就已经配置好了，打开*.xcworkspace，没错，再也不是*.xcodeproj文件了。链接你的设备，使用配置好的Pods，run一下你的程序吧~ Note: 每次更改了 Podfile 文件，你需要重新执行一次pod update命令。 三个重要的知识点 当执行pod install之后，除了Podfile，还会生成一个名为Podfile.lock的文件，它会锁定当前各依赖库的版本，之后即使多次执行pod install也不会更改版本，只有执行pod update才会改变Podfile.lock.在多人协作的时候，这样可以防止第三方库升级时候造成大家各自的第三方库版本不一致，所以在往SVN提交版本的时候不能把它落下。（个人认为可以把它从ignore列表中删掉） Pods项目最终会编译成一个名为libPods.a的文件，主项目只需要依赖这个.a文件即可，这个文件一般在项目的frameworks文件夹下。 CocoaPods通过一个名为Pods.xcconfig的文件来在编译时设置所有的依赖和参数。###结语这次重命名项目让我好好的研究了一把CocoaPods，毕竟之前都是直接看教程敲命令行😂。不过还是要吐槽一下pod setup的下载速度楼主表示，都怪你让我连输了三把排位！ヽ(ˋДˊ)ノヽ(ˋДˊ)ノヽ(ˋДˊ)ノ 其他简书地址","tags":[{"name":"CocoaPods相关","slug":"CocoaPods相关","permalink":"http://boysimonhu.com/tags/CocoaPods%E7%9B%B8%E5%85%B3/"}]}]